function outfiles = save_canlab_image_as_nifti(imgobj, outfname, varargin)
% SAVE_CANLAB_IMAGE_AS_NIFTI  Save a canlab image object to NIfTI(s)
%
% outfiles = save_canlab_image_as_nifti(imgobj, outfname)
% outfiles = save_canlab_image_as_nifti(imgobj, outfname, 'index', 1, 'fourD', false, 'overwrite', true)
%
% Inputs:
%  - imgobj: canlab image object (image_vector, statistic_image, fmri_data, contrast object)
%           must have fields: .dat (nV x nImages) and .volInfo (with wh_inmask or image_indx)
%  - outfname: output filename pattern. If dat has multiple columns and 'fourD'==false,
%              filenames will be generated by appending _01,_02 etc. e.g. 'mystat.nii' ->
%              'mystat_01.nii' 'mystat_02.nii' ...
%
% Optional name/value:
%  - 'index'      : integer or vector of column indices to write (default: all)
%  - 'fourD'      : logical. If true and multiple indices, writes a single 4D file
%                   (requires SPM that supports writing 4D headers) (default: false)
%  - 'overwrite'  : overwrite existing files (default: false)
%
% Output:
%  - outfiles: cell array of written filenames
%
% Notes:
%  - Requires SPM on path (spm_vol / spm_write_vol). Call spm('Defaults','FMRI') first if needed.
%  - The function expects volInfo.wh_inmask to contain linear indices into the full volume.
%    If only volInfo.image_indx (logical vector) is present, that is also accepted.
%
% Example:
%   save_canlab_image_as_nifti(fmriDat, 'group_t.nii', 'index', 1, 'overwrite', true);

% --- parse inputs
p = inputParser;
addParameter(p,'index',[], @(x)isnumeric(x));
addParameter(p,'fourD',false,@islogical);
addParameter(p,'overwrite',false,@islogical);
parse(p,varargin{:});
idx = p.Results.index;
use4D = p.Results.fourD;
overwrite = p.Results.overwrite;

% basic checks
if ~isfield(imgobj, 'dat') || ~isfield(imgobj, 'volInfo')
    error('imgobj must have fields .dat and .volInfo (typical for canlab image objects).');
end

dat = imgobj.dat;            % nV x nImages (or nV x 1)
if isempty(dat)
    error('imgobj.dat is empty.');
end

% ensure dat is nV x ncols
[nV, nCols] = size(dat);

if isempty(idx)
    idx = 1:nCols;
else
    idx = idx(idx >= 1 & idx <= nCols);
    if isempty(idx), error('No valid indices requested.'); end
end

% find a template/header to base output on
volInfo = imgobj.volInfo;
Vtemplate = [];

% prefer volInfo.V if available (SPM vol struct)
if isfield(volInfo, 'V') && ~isempty(volInfo.V)
    Vtemplate = volInfo.V(1); % use first header
elseif isfield(volInfo, 'image_names') && ~isempty(volInfo.image_names)
    try
        Vtemplate = spm_vol(volInfo.image_names{1});
    catch
        error('Could not read template from volInfo.image_names{1}. Ensure SPM is on the path.');
    end
else
    error('No suitable template header found in volInfo. Need volInfo.V or volInfo.image_names{1}.');
end

% determine where to place voxel values in full volume
% prefer wh_inmask (list of linear indices into full volume), else image_indx logical vector
if isfield(volInfo, 'wh_inmask') && ~isempty(volInfo.wh_inmask)
    mask_idx = volInfo.wh_inmask(:);
elseif isfield(volInfo, 'image_indx') && ~isempty(volInfo.image_indx)
    % image_indx may be logical vector
    img_ind = volInfo.image_indx(:);
    if islogical(img_ind)
        mask_idx = find(img_ind);
    else
        mask_idx = find(img_ind);
    end
else
    error('volInfo must contain .wh_inmask or .image_indx to map data back to 3D volume.');
end

% full volume dims from template
volDims = Vtemplate.dim; % [X Y Z]

% helper to write single 3D volume
    function write_one(vec, fname)
        if ~isscalar(vec) && numel(vec) ~= numel(mask_idx)
            error('Data vector length (%d) does not match mask size (%d).', numel(vec), numel(mask_idx));
        end
        % build full 3D
        fullvol = zeros(volDims, 'single');
        fullvol(mask_idx) = single(vec);
        % prepare header
        Vout = Vtemplate;
        Vout.fname = fname;
        % set datatype to single (FLOAT32): spm uses [16 0] code
        try
            Vout.dt = [16 0];
        catch
            % some SPM versions may not allow direct dt assignment; ignore if fails
        end
        % write
        spm_write_vol(Vout, fullvol);
    end

% prepare output filenames
outfiles = {};
base = outfname;
[~,~,ext] = fileparts(base);
if isempty(ext)
    base = [base '.nii'];
    ext = '.nii';
end

if numel(idx) == 1 || ~use4D
    % write 1 file per selected index
    for k = 1:numel(idx)
        i = idx(k);
        if numel(idx) == 1
            fname = base;
        else
            % append _01 etc before extension
            fname = sprintf('%s_%02d%s', base(1:end-numel(ext)), k, ext);
        end
        if exist(fname, 'file') && ~overwrite
            error('File exists: %s. Use ''overwrite'', true to overwrite.', fname);
        end
        write_one(dat(:,i), fname);
        outfiles{end+1} = fname; %#ok<AGROW>
    end
else
    % write single 4D file (stack volumes along 4th dim)
    % Create a 4D array [X Y Z nVols] - careful with memory
    nWrite = numel(idx);
    big4d = zeros([volDims nWrite], 'single');
    for k = 1:nWrite
        big4d(:,:, : , k) = reshape(zeros(prod(volDims),1,'single'), volDims); %# placeholder
        % fill mask positions
        tmp = zeros(prod(volDims),1,'single');
        tmp(mask_idx) = single(dat(:, idx(k)));
        big4d(:,:,:,k) = reshape(tmp, volDims);
    end
    if exist(base,'file') && ~overwrite
        error('File exists: %s. Use ''overwrite'', true to overwrite.', base);
    end
    % prepare header array and write
    Vout = repmat(Vtemplate, 1, nWrite);
    for k = 1:nWrite
        Vout(k).fname = base;
        Vout(k).n = [k 1]; % specify 4D index
        try
            Vout(k).dt = [16 0];
        catch
        end
        spm_write_vol(Vout(k), big4d(:,:,:,k));
    end
    outfiles{1} = base;
end

end
